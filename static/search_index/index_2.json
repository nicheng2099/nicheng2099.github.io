{"/Linux/CentOS 7 yum安装 MySQL 5.7.html":{"title":"CentOS 7 yum安装 MySQL 5.7","content":"# CentOS 7 yum安装 MySQL 5.7 1、下载命令 ``` wget https://dev.mysql.com/get/mysql57 community release el7 9.noarch.rpm ``` 2、yun源安装命令 ``` rpm ivh mysql57 community release el7 9.noarch.rpm ``` 3、使用yum命令安装mysql ``` yum y install mysql server ``` 4、启动mysql ``` systemctl start mysqld ``` 5、检查是否安装启动成功 ``` systemctl status mysqld ``` 6、查看默认密码 ``` grep 'temporary password' /var/log/mysqld.log ``` 7、登录修改密码 ``` mysql u root p ``` 8、修改密码 因为5.7及以上版本的数据库对密码做了强度要求，默认密码的要求必须是大小写字母数字特殊字母的组合且至少要8位长度 ``` ALTER USER 'root'@'localhost' IDENTIFIED BY '新的密码Lichao.123'; ``` 9、允许远程登录 ``` GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '密码Lichao.123' WITH GRANT OPTION; ``` 10、如仍然无法访问则需关闭防火墙或者开放3306端口访问权限 附：CentOS 7 关闭防火墙命令 ``` firewall cmd zone public add port 3306/tcp permanent systemctl restart firewalld.service ```"},"/Linux/Docker/index.html":{"title":"Docker","content":"# Docker ## 安装docker ```shell # 1. 卸载当前可能存在的 Docker 残留 sudo apt get remove docker docker engine docker.io containerd runc # 2. 安装基础依赖 sudo apt get update sudo apt get install y \\ apt transport https \\ ca certificates \\ curl \\ gnupg \\ lsb release # 3. 使用阿里云镜像源 curl fsSL https://mirrors.aliyun.com/docker ce/linux/ubuntu/gpg sudo gpg dearmor o /usr/share/keyrings/docker archive keyring.gpg # 4. 添加阿里云 Docker 源 echo \\ \"deb [arch amd64 signed by /usr/share/keyrings/docker archive keyring.gpg] https://mirrors.aliyun.com/docker ce/linux/ubuntu \\ $(lsb_release cs) stable\" sudo tee /etc/apt/sources.list.d/docker.list > /dev/null # 5. 更新并安装 Docker sudo apt get update sudo apt get install y docker ce docker ce cli containerd.io docker compose plugin # 6. 启动 Docker 服务 sudo systemctl start docker sudo systemctl enable docker # 7. 验证安装 sudo docker version sudo systemctl status docker # 8. 将当前用户加入docker组 sudo usermod aG docker $USER newgrp docker ``` ## 安装docker compose ```shell # 更新包列表 sudo apt update # 安装 docker compose sudo apt install y docker compose # 验证安装 docker compose version ``` ## 镜像加速 ```shell # 编辑daemon.json 没有就创建 sudo vim /etc/docker/daemon.json # 添加镜像加速，当前可用的镜像： # https://docker.m.ixdev.cn/ https://docker.1ms.run # https://1ms.run/ https://m.ixdev.cn/ sudo tee /etc/docker/daemon.json << EOF { \"registry mirrors\": [\"https://docker.1ms.run\"] } EOF # 重启docker sudo systemctl daemon reload sudo systemctl restart docker ``` 检查镜像 ```shell sudo docker run hello world ```"},"/Linux/Docker/Docker部署Nginx.html":{"title":"Docker部署Nginx","content":"# Docker部署Nginx ## 不添加映射 ### 拉取Nginx ```shell sudo docker pull nginx:latest ``` ### 查看是否拉取成功 ```shell sudo docker images ``` ### 运行容器 ```shell sudo docker run name nginx test p 8080:80 d nginx ``` ## 添加本地映射文件结构 > /home/lc_link/nginx/ > ├── html/ > > │ └── index.html # 你的自定义页面 > ├── conf.d/ > │ └── app.conf # Nginx配置 > ├── logs/ # 日志目录（空，容器启动后会有日志） > └── certs/ # SSL证书目录（可选） ### 在任意地方创建映射文件目录 ```shell # 切换到根目录或你习惯的工作目录，这里以 /docker 为例 sudo mkdir p ~/nginx cd ~/nginx # 创建子目录，分别用于存放配置、静态网页、日志 sudo mkdir conf.d html logs certs ``` ### 配置静态资源 ```shell # 创建index静态资源 cat > /home/lc_link/nginx/html/index.html << EOF <!DOCTYPE html> <html> <head> <title>Welcome to My Nginx LC_LINK!</title> </head> <body> <h1>Success! Nginx is running in a Docker container.</h1> <p>This is a test page from the host machine.</p> </body> </html> EOF ``` ### 配置conf文件 ```shell # 创建Nginx配置文件 cat > /home/lc_link/nginx/conf.d/app.conf << EOF server { listen 80; server_name _; # 重要：指向容器内的标准HTML目录 root /usr/share/nginx/html; index index.html index.htm; location / { try_files $uri $uri/ 404; } # 访问日志和错误日志 access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; } EOF ``` ### 使用挂载路径运行容器 ```shell sudo docker run d \\ name my nginx \\ p 80:80 \\ v /home/lc_link/nginx/html:/usr/share/nginx/html:ro \\ v /home/lc_link/nginx/conf.d:/etc/nginx/conf.d:ro \\ v /home/lc_link/nginx/logs:/var/log/nginx \\ restart unless stopped \\ nginx:1.24 ``` ### 验证部署 ```shell # 1. 检查容器状态 sudo docker ps # 2. 测试访问 这次应该看到你的自定义页面 curl http://localhost # 3. 验证挂载是否正确 sudo docker exec my nginx ls la /usr/share/nginx/html/ # 4. 检查配置文件是否加载 sudo docker exec my nginx cat /etc/nginx/conf.d/app.conf # 5. 查看容器日志 sudo docker logs my nginx ``` ## 容器常用命令 ```bash # 停止容器 sudo docker stop my nginx # 启动容器 sudo docker start my nginx # 重启容器（例如修改配置后） sudo docker restart my nginx # 进入容器内部（用于调试，一般情况下应避免） sudo docker exec it my nginx /bin/bash # 删除容器（如果需要重新配置） sudo docker stop my nginx sudo docker rm my nginxx ``` ## Nginx <a class \"btn\" href \"/doc3/Nginx/index.html\">学习Nginx</a>"},"/Linux/克隆模板机.html":{"title":"克隆模板机","content":"# 克隆模板机 ## 克隆一个空的模块机 ![](assets/2025 10 29 14 34 20 image.png) ![](assets/2025 10 29 14 36 20 image.png) ![](assets/2025 10 29 14 36 51 image.png) ![](assets/2025 10 29 14 37 18 image.png) ![](assets/2025 10 29 14 38 54 image.png) ## 配置克隆的虚拟机 配置静态ip ```shell sudo nano /etc/netplan/50 cloud init.yaml ``` ```shell network: version: 2 ethernets: ens33: addresses: \"192.168.100.103/24\" nameservers: addresses: 8.8.8.8 search: [] routes: to: \"default\" via: \"192.168.100.2\" ``` ```shell sudo netplan apply ``` 配置主机名 ```shell sudo hostnamectl set hostname odoo addons 103 ``` ```shell sudo nano /etc/hosts ``` ```shell 127.0.0.1 localhost 127.0.1.1 odoo addons 103 # The following lines are desirable for IPv6 capable hosts ::1 ip6 localhost ip6 loopback fe00::0 ip6 localnet ff00::0 ip6 mcastprefix ff02::1 ip6 allnodes ff02::2 ip6 allrouters ``` ```shell sudo reboot ```"},"/Linux/NFS网络文件.html":{"title":"NFS网络文件","content":"# NFS网络文件 ## 准备两个ubantu系统 > 存储服务器ip：192.168.100.105 > > 挂载服务器ip：192.168.100.102 ## 在存储服务器上配置NFS（192.168.100.105） > 1000是用户id，通过id u 或者id g查看 ```shell # 安装NFS服务 sudo apt update sudo apt install nfs kernel server # 创建共享目录 sudo mkdir p /odoo_shared_data sudo chown 1000:1000 /odoo_shared_data # 配置导出 sudo nano /etc/exports ``` ```ini /odoo_shared_data 192.168.100.102(rw,sync,no_subtree_check) ``` ```bash # 重新加载NFS配置 sudo exportfs ra sudo systemctl restart nfs server # 检查NFS共享 sudo showmount e localhost ``` ## 在挂载服务器上挂载NFS（192.168.100.102） ```bash # 安装NFS客户端 sudo apt update sudo apt install nfs common # 创建挂载点 sudo mkdir p /mnt/odoo_shared # 挂载NFS sudo mount t nfs 192.168.100.105:/odoo_shared_data /mnt/odoo_shared # 设置开机自动挂载 echo \"192.168.100.105:/odoo_shared_data /mnt/odoo_shared nfs defaults 0 0\" sudo tee a /etc/fstab ```"},"/Linux/linux mysql 操作命令.html":{"title":"linux mysql 操作命令","content":"# linux mysql 操作命令 1.linux下启动mysql的命令： mysqladmin start /ect/init.d/mysql start (前面为mysql的安装路径) 2.linux下重启mysql的命令： mysqladmin restart /ect/init.d/mysql restart (前面为mysql的安装路径) 3.linux下关闭mysql的命令： mysqladmin shutdown /ect/init.d/mysql shutdown (前面为mysql的安装路径) 4.连接本机上的mysql： 进入目录mysql\\bin，再键入命令mysql uroot p， 回车后提示输入密码。 退出mysql命令：exit（回车） 5.修改mysql密码： mysqladmin u用户名 p旧密码 password 新密码 或进入mysql命令行SET PASSWORD FOR root PASSWORD(\"root\"); 6.增加新用户。（注意：mysql环境中的命令后面都带一个分号作为命令结束符） grant select on 数据库.* to 用户名@登录主机 identified by \"密码\" 如增加一个用户test密码为123，让他可以在任何主机上登录， 并对所有数据库有查询、插入、修改、删除的权限。首先用以root用户连入mysql，然后键入以下命令： grant select,insert,update,delete on *.* to \" Identified by \"123\"; 二、有关mysql数据库方面的操作 必须首先登录到mysql中，有关操作都是在mysql的提示符下进行，而且每个命令以分号结束 1、显示数据库列表。 show databases; 2、显示库中的数据表： use mysql； ／／打开库 show tables; 3、显示数据表的结构： describe 表名; 4、建库： create database 库名; GBK: create database test2 DEFAULT CHARACTER SET gbk COLLATE gbk_chinese_ci; UTF8: CREATE DATABASE `test2` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; 5、建表： use 库名； create table 表名(字段设定列表)； 6、删库和删表: drop database 库名; drop table 表名； 7、将表中记录清空： delete from 表名; truncate table 表名; 8、显示表中的记录： select * from 表名; 9、编码的修改 如果要改变整个mysql的编码格式： 启动mysql的时候，mysqld_safe命令行加入 default character set gbk 如果要改变某个库的编码格式：在mysql提示符后输入命令 alter database db_name default character set gbk; 10.重命名表 alter table t1 rename t2; 11.查看sql语句的效率 explain < table_name > 例如：explain select * from t3 where id 3952602; 12.用文本方式将数据装入数据库表中(例如D:/mysql.txt) mysql> LOAD DATA LOCAL INFILE \"D:/mysql.txt\" INTO TABLE MYTABLE; 三、数据的导入导出 1、文本数据转到数据库中 文本数据应符合的格式：字段数据之间用tab键隔开，null值用来代替。例： 1 name duty 2006 11 23 数据传入命令 load data local infile \"文件名\" into table 表名; 2、导出数据库和表 mysqldump opt news > news.sql（将数据库news中的所有表备份到news.sql文件，news.sql是一个文本文件，文件名任取。） mysqldump opt news author article > author.article.sql（将数据库news中的author表和article表备份到author.article.sql文件， author.article.sql是一个文本文件，文件名任取。） mysqldump databases db1 db2 > news.sql（将数据库dbl和db2备份到news.sql文件，news.sql是一个文本文件，文件名任取。） mysqldump h host u user p pass databases dbname > file.dump 就是把host上的以名字user，口令pass的数据库dbname导入到文件file.dump中 mysqldump all databases > all databases.sql（将所有数据库备份到all databases.sql文件，all databases.sql是一个文本文件，文件名任取。） 3、导入数据 mysql < all databases.sql（导入数据库） mysql>source news.sql;（在mysql命令下执行，可导入表） 一、连接MySQL 格式： mysql h主机地址 u用户名 －p用户密码 1、例1：连接到本机上的MYSQL。 首先在打开DOS窗口，然后进入目录 mysqlbin，再键入命令mysql uroot p，回车后提示你输密码，如果刚安装好MYSQL，超级用户root是没有密码的，故直接回车即可进入到MYSQL中了，MYSQL的提示符是： mysql>。 2、例2：连接到远程主机上的MYSQL。假设远程主机的IP为：110.110.110.110，用户名为root,密码为abcd123。则键入以下命令： mysql h110.110.110.110 uroot pabcd123 （注:u与root可以不用加空格，其它也一样） 3、退出MYSQL命令： exit （回车）。 二、修改密码 格式：mysqladmin u用户名 p旧密码 password 新密码 1、例1：给root加个密码ab12。首先在DOS下进入目录mysqlbin，然后键入以下命令： mysqladmin uroot password ab12 注：因为开始时root没有密码，所以 p旧密码一项就可以省略了。 2、例2：再将root的密码改为djg345。 mysqladmin uroot pab12 password djg345 三、增加新用户。（注意：和上面不同，下面的因为是MySQL环境中的命令，所以后面都带一个分号作为命令结束符） 格式：grant select on 数据库.* to 用户名@登录主机 identified by \\\"密码\\\" 例1、增加一个用户test1密码为abc，让他可以在任何主机上登录，并对所有数据库有查询、插入、修改、删除的权限。首先用以root用户连入MySQL，然后键入以下命令： grant select,insert,update, delete on *.* to test1@\\\"%\\\" Identified by \\\"abc\\\"; 但例1增加的用户是十分危险的，你想如某个人知道test1的密码，那么他就可以在internet上的任何一台电脑上登录你的MySQL数据库并对你的数据可以为所欲为了，解决办法见例2。 例2、增加一个用户test2密码为abc,让他只可以在localhost上登录，并可以对数据库mydb进行查询、插入、修改、删除的操作 （localhost指本地主机，即MySQL数据库所在的那台主机），这样用户即使用知道test2的密码，他也无法从internet上直接访问数据 库，只能通过MySQL主机上的web页来访问。 grant select,insert,update, delete on mydb.* to test2@localhost identified by \\\"abc\\\"; 如果你不想test2有密码，可以再打一个命令将密码消掉。 grant select,insert,update,delete on mydb .* to test2@localhost identified by \\\"\\\"; 启动：net start mySql; 进入：mysql u root p/mysql h localhost u root p databaseName; 列出数据库：show databases; 选择数据库：use databaseName; 列出表格：show tables； 显示表格列的属性：show columns from tableName； 建立数据库：source fileName.txt; 匹配字符：可以用通配符_代表任何一个字符，％代表任何字符串; 增加一个字段：alter table tabelName add column fieldName dateType; 增加多个字段：alter table tabelName add column fieldName1 dateType,add columns fieldName2 dateType; 多行命令输入:注意不能将单词断开;当插入或更改数据时，不能将字段的字符串展开到多行里，否则硬回车将被储存到数据中; 增加一个管理员帐户：grant all on *.* to user@localhost identified by \"password\"; 每条语句输入完毕后要在末尾填加分号';'，或者填加'\\g'也可以； 查询时间：select now(); 查询当前用户：select user(); 查询数据库版本：select version(); 查询当前使用的数据库：select database(); 1、删除student_course数据库中的students数据表： rm f student_course/students.* 2、备份数据库：(将数据库test备份) mysqldump u root p test>c:\\test.txt 备份表格：(备份test数据库下的mytable表格) mysqldump u root p test mytable>c:\\test.txt 将备份数据导入到数据库：(导回test数据库) mysql u root p test 3、创建临时表：(建立临时表zengchao) create temporary table zengchao(name varchar(10)); 4、创建表是先判断表是否存在 create table if not exists students(……); 5、从已经有的表中复制表的结构 create table table2 select * from table1 where 1<>1; 6、复制表 create table table2 select * from table1; 7、对表重新命名 alter table table1 rename as table2; 8、修改列的类型 alter table table1 modify id int unsigned;//修改列id的类型为int unsigned alter table table1 change id sid int unsigned;//修改列id的名字为sid，而且把属性修改为int unsigned 9、创建索引 alter table table1 add index ind_id (id); create index ind_id on table1 (id); create unique index ind_id on table1 (id);//建立唯一性索引 10、删除索引 drop index idx_id on table1; alter table table1 drop index ind_id; 11、联合字符或者多个列(将列id与\":\"和列name和\" \"连接) select concat(id,':',name,' ') from students; 12、limit(选出10到20条)<第一个记录集的编号是0> select * from students order by id limit 9,10; 13、MySQL不支持的功能 事务，视图，外键和引用完整性，存储过程和触发器 14、MySQL会使用索引的操作符号 <,< ,> ,>, ,between,in,不带%或者_开头的like 15、使用索引的缺点 1)减慢增删改数据的速度； 2）占用磁盘空间； 3）增加查询优化器的负担； 当查询优化器生成执行计划时，会考虑索引，太多的索引会给查询优化器增加工作量，导致无法选择最优的查询方案； 16、分析索引效率 方法：在一般的SQL语句前加上explain； 分析结果的含义： 1）table：表名； 2）type：连接的类型，(ALL/Range/Ref)。其中ref是最理想的； 3）possible_keys：查询可以利用的索引名； 4）key：实际使用的索引； 5）key_len：索引中被使用部分的长度（字节）； 6）ref：显示列名字或者\"const\"（不明白什么意思）； 7）rows：显示MySQL认为在找到正确结果之前必须扫描的行数； 8）extra：MySQL的建议； 17、使用较短的定长列 1）尽可能使用较短的数据类型； 2）尽可能使用定长数据类型； a）用char代替varchar，固定长度的数据处理比变长的快些； b）对于频繁修改的表，磁盘容易形成碎片，从而影响数据库的整体性能； c）万一出现数据表崩溃，使用固定长度数据行的表更容易重新构造。使用固定长度的数据行，每个记录的开始位置都是固定记录长度的倍数，可以很容易被检测到，但是使用可变长度的数据行就不一定了； d）对于MyISAM类型的数据表，虽然转换成固定长度的数据列可以提高性能，但是占据的空间也大； 18、使用not null和enum 尽量将列定义为not null，这样可使数据的出来更快，所需的空间更少，而且在查询时，MySQL不需要检查是否存在特例，即null值，从而优化查询； 如果一列只含有有限数目的特定值，如性别，是否有效或者入学年份等，在这种情况下应该考虑将其转换为enum列的值，MySQL处理的更快，因为所有的enum值在系统内都是以标识数值来表示的； 19、使用optimize table 对于经常修改的表，容易产生碎片，使在查询数据库时必须读取更多的磁盘块，降低查询性能。具有可变长的表都存在磁盘碎片问题，这个问题对blob数据类型更为突出，因为其尺寸变化非常大。可以通过使用optimize table来整理碎片，保证数据库性能不下降，优化那些受碎片影响的数据表。 optimize table可以用于MyISAM和BDB类型的数据表。实际上任何碎片整理方法都是用mysqldump来转存数据表，然后使用转存后的文件并重新建数据表； 20、使用procedure analyse() 可以使用procedure analyse()显示最佳类型的建议，使用很简单，在select语句后面加上procedure analyse()就可以了；例如： select * from students procedure analyse(); select * from students procedure analyse(16,256); 第二条语句要求procedure analyse()不要建议含有多于16个值，或者含有多于256字节的enum类型，如果没有限制，输出可能会很长； 21、使用查询缓存 1）查询缓存的工作方式： 第一次执行某条select语句时，服务器记住该查询的文本内容和查询结果，存储在缓存中，下次碰到这个语句时，直接从缓存中返回结果；当更新数据表后，该数据表的任何缓存查询都变成无效的，并且会被丢弃。 2）配置缓存参数： 变量：query_cache _type，查询缓存的操作模式。有3中模式，0：不缓存；1：缓存查询，除非与 select sql_no_cache开头；2：根据需要只缓存那些以select sql_cache开头的查询； query_cache_size：设置查询缓存的最大结果集的大小，比这个值大的不会被缓存。 22、调整硬件 1）在机器上装更多的内存； 2）增加更快的硬盘以减少I/O等待时间； 寻道时间是决定性能的主要因素，逐字地移动磁头是最慢的，一旦磁头定位，从磁道读则很快； 3）在不同的物理硬盘设备上重新分配磁盘活动； 如果可能，应将最繁忙的数据库存放在不同的物理设备上，这跟使用同一物理设备的不同分区是不同的，因为它们将争用相同的物理资源（磁头）。 ## 删除MySQL数据库 1、创建数据库 mysql> create database drop_database; Query OK, 1 row affected (0.00 sec) 2、删除一个已经确定存在的数据库 mysql> drop database drop_database; Query OK, 0 rows affected ( 0.00 sec) 3、删除一个不确定存在的数据库 mysql> drop database drop_database; ERROR 1008 (HY000): Can't drop database 'drop_database'; database doesn't exist //发生错误，不能删除'drop_database'数据库，该数据库不存在。 mysql> drop database if exists drop_database; Query OK, 0 rows affected, 1 warning (0.00 sec)//产生一个警告说明此数据库不存在 mysql> create database drop_database; Query OK, 1 row affected (0.00 sec) mysql> drop database if exists drop_database;//if exists 判断数据库是否存在，不存在也不产生错误 Query OK, 0 rows affected (0.00 sec)"},"/Linux/Grafana/在Ubuntu上部署Grafana.html":{"title":"在 Ubuntu 上部署 Grafana","content":"# 在 Ubuntu 上部署 Grafana ## 方法一：使用官方APT仓库 ### 步骤1：更新系统包 ```shell sudo apt update sudo apt upgrade y ``` ### 步骤2：安装必要的依赖 ```shell sudo apt install y software properties common wget curl gnupg ``` ### 步骤3：添加Grafana官方GPG密钥 ```shell sudo mkdir p /etc/apt/keyrings/ wget q O https://apt.grafana.com/gpg.key gpg dearmor sudo tee /etc/apt/keyrings/grafana.gpg > /dev/null ``` ### 步骤4：添加Grafana APT仓库 ```shell echo \"deb [signed by /etc/apt/keyrings/grafana.gpg] https://apt.grafana.com stable main\" sudo tee /etc/apt/sources.list.d/grafana.list ``` ### 步骤5：更新包列表并安装Grafana ```shell sudo apt update sudo apt install grafana y ``` ### 步骤6：启动并启用Grafana服务 ```shell # 启动Grafana服务 sudo systemctl start grafana server # 设置开机自启 sudo systemctl enable grafana server # 检查服务状态 sudo systemctl status grafana server ``` ## 方法二：使用Docker部署 ### 步骤1：安装Docker ```shell # 安装Docker curl fsSL https://get.docker.com o get docker.sh sudo sh get docker.sh # 将当前用户添加到docker组 sudo usermod aG docker $USER newgrp docker ``` ### 步骤2：使用Docker运行Grafana ```shell # 创建数据目录 sudo mkdir p /docker/grafana/data sudo chmod 777 /docker/grafana/data # 运行Grafana容器 docker run d \\ name grafana \\ p 3000:3000 \\ v /docker/grafana/data:/var/lib/grafana \\ e \"GF_SECURITY_ADMIN_PASSWORD admin123\" \\ grafana/grafana oss:latest ``` ## 配置Grafana ### 步骤1：访问Grafana Web界面 • 打开浏览器访问：`http://你的服务器IP:3000` • 默认用户名：`admin` • 默认密码：`admin`（首次登录后会要求修改） ### 步骤2：基本配置 ```shell # 编辑Grafana配置文件 sudo nano /etc/grafana/grafana.ini ``` 主要配置项： ```shell [server] # 监听地址（设置为0.0.0.0允许外部访问） http_addr 0.0.0.0 http_port 3000 [database] # 数据库配置（默认使用SQLite） ;type sqlite3 ;path grafana.db [security] # 安全配置 admin_user admin admin_password admin ``` ### 步骤3：重启服务应用配置 ```shell sudo systemctl restart grafana server ``` ## 防火墙配置 ### 如果使用UFW防火墙 ```shell # 允许3000端口 sudo ufw allow 3000/tcp sudo ufw reload ``` ### 如果使用iptables ```shell sudo iptables A INPUT p tcp dport 3000 j ACCEPT ``` ## 数据持久化目录 Grafana的重要数据位置： • 配置文件：`/etc/grafana/grafana.ini` • 数据文件：`/var/lib/grafana` • 日志文件：`/var/log/grafana` • 插件目录：`/var/lib/grafana/plugins` ## 常用管理命令 ```shell # 启动服务 sudo systemctl start grafana server # 停止服务 sudo systemctl stop grafana server # 重启服务 sudo systemctl restart grafana server # 查看服务状态 sudo systemctl status grafana server # 查看日志 sudo journalctl u grafana server f ``` ## 备份和恢复 ### 备份Grafana数据 ```shell # 备份配置和数据 sudo tar czf grafana backup $(date +%Y%m%d).tar.gz /etc/grafana /var/lib/grafana ``` ### 恢复Grafana数据 ```shell # 停止Grafana服务 sudo systemctl stop grafana server # 恢复备份 sudo tar xzf grafana backup 20231201.tar.gz C / # 启动服务 sudo systemctl start grafana server ``` ## 故障排除 ### 常见问题解决 1. 1. **端口被占用** ```shell # 检查3000端口占用 sudo netstat tulpn grep 3000 # 如果被占用，修改Grafana端口或停止占用程序 ``` 1. 2. **无法访问Web界面** ```shell # 检查防火墙设置 sudo ufw status # 检查Grafana服务状态 sudo systemctl status grafana server # 查看日志 sudo journalctl u grafana server n 50 ``` 1. 3. **权限问题** ```shell # 修复数据目录权限 sudo chown R grafana:grafana /var/lib/grafana sudo chmod 755 /var/lib/grafana ``` ## 后续步骤 1. 1. **添加数据源**：配置Prometheus、InfluxDB等数据源 2. 2. **安装插件**：根据需求安装相关插件 3. 3. **创建仪表板**：设计监控仪表板 4. 4. **设置警报**：配置监控警报规则 这样就完成了Grafana在Ubuntu上的部署！"},"/Linux/lvs实操.html":{"title":"1.物理机器（4台）","content":"# 1.物理机器（4台） ![](./p/15.png) ```bash VIP:192.168.11.7 K1:192.168.11.3 K2:192.168.11.4 NG1:192.168.11.5 NG2:192.168.11.6 ``` # 2.K1 ```bash apt install y keepalive ``` ## Keepalived.conf /etc/keepalived/keepalived.conf ``` global_defs { notification_email { 39820581@qq.com } #notification_email_from guoxm@puzek.com #smtp_server smtp.mxhichine.com #smtp_connect_timeout 30 vrrp_mcast_group4 224.0.0.18 router_id LVSMASTER } vrrp_instance VI_1 { state MASTER interface ens33 virtual_router_id 137 priority 7 advert_int 3 authentication { auth_type PASS auth_pass abclmh } virtual_ipaddress { 192.168.11.7/24 dev ens33 } virtual_ipaddress_excluded { fd15:4ba5:5a2b:1003::7/128 dev ens33 } } # http virtual_server 192.168.11.7 80 { delay_loop 6 #每隔6秒检查一次real server状态 lb_algo wrr lb_kind DR #LVS 集群模式 # persistence_timeout 50 protocol TCP real_server 192.168.11.5 80 { weight 1 TCP_CHECK { connect_timeout 3 } } real_server 192.168.11.6 80 { weight 1 TCP_CHECK { connect_timeout 3 } } } virtual_server fd15:4ba5:5a2b:1003::7 80 { delay_loop 6 #每隔6秒检查一次real server状态 lb_algo wrr lb_kind DR #LVS 集群模式 # persistence_timeout 50 protocol TCP real_server fd15:4ba5:5a2b:1003::5 80 { weight 2 TCP_CHECK { connect_timeout 3 } } real_server fd15:4ba5:5a2b:1003::6 80 { weight 2 TCP_CHECK { connect_timeout 3 } } } ``` ## k2 ```bash global_defs { notification_email { 39820581@qq.com } #notification_email_from guoxm@puzek.com #smtp_server smtp.mxhichine.com #smtp_connect_timeout 30 vrrp_mcast_group4 224.0.0.18 router_id LVSMASTER } vrrp_instance VI_1 { state MASTER interface ens33 virtual_router_id 137 priority 8 advert_int 3 authentication { auth_type PASS auth_pass abclmh } virtual_ipaddress { 192.168.11.7/24 dev ens33 } virtual_ipaddress_excluded { fd15:4ba5:5a2b:1003::7/128 dev ens33 } } # http virtual_server 192.168.11.7 80 { delay_loop 6 #每隔6秒检查一次real server状态 lb_algo wrr lb_kind DR #LVS 集群模式 # persistence_timeout 50 protocol TCP real_server 192.168.11.5 80 { weight 1 TCP_CHECK { connect_timeout 3 } } real_server 192.168.11.6 80 { weight 1 TCP_CHECK { connect_timeout 3 } } } virtual_server fd15:4ba5:5a2b:1003::7 80 { delay_loop 6 #每隔6秒检查一次real server状态 lb_algo wrr lb_kind DR #LVS 集群模式 # persistence_timeout 50 protocol TCP real_server fd15:4ba5:5a2b:1003::5 80 { weight 2 TCP_CHECK { connect_timeout 3 } } real_server fd15:4ba5:5a2b:1003::6 80 { weight 2 TCP_CHECK { connect_timeout 3 } } } ``` # 3.nginx ## 1.为lo增加地址VIP ```bash # This is the network config written by 'subiquity' network: ethernets: ens33: addresses: 192.168.11.5/24 fd15:4ba5:5a2b:1003::5/64 gateway4: 192.168.11.1 nameservers: addresses: 10.6.6.6 search: lzhit.edu.cn lo: addresses: 192.168.11.7/32 fd15:4ba5:5a2b:1003::7/128 version: 2 ``` ## 2./etc/sysctl.conf ```bash net.ipv4.conf.lo.arp_ignore 1 net.ipv4.conf.lo.arp_announce 2 net.ipv4.conf.all.arp_ignore 1 net.ipv4.conf.all.arp_announce 2 net.ipv4.conf.default.arp_ignore 1 net.ipv4.conf.default.arp_announce 2 ``` 记得 执行sysctl p 其他的RealServers除了自身的IP不一样以外，其他都一样 # 4.结果 keepalive ![](./p/16.png) ng ![](./p/17.png) ipvsadm L n ![](./p/18.png) 实际测试结果： ![](./p/19.png) ![](./p/20.png)"},"/Linux/index.html":{"title":"Linux","content":"# Linux # 第一章 Linux操作系统概述 **Linux的特点**：开放性、多用户、多任务、良好的用户界面、设备独立性、提供丰富的网络功能、可靠的系统安全性、良好的可移植性 、兼容其他Unix系统 、支持多种文件系统 ### 目录结构 ![](image1/17.jpg) **/bin**: bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。 **/usr**: usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。 **/dev**: dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。 **/etc**: etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。 **/home**: 用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。 **/srv**: 该目录存放一些服务启动之后需要提取的数据。 **/var**: var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 **/lib**: lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。 **/lost+found**: 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 **/media**: linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。 **/mnt**: 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。 **/opt**: opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 **/root**: 该目录为系统管理员，也称作超级权限者的用户主目录。 **/boot**: 这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。 **/tmp**: tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。 **注**：Linux存储用户帐号的文件是:**/etc/passwd**； Linux存储密码和群组名称的文件是:**/etc/shadow**； Linux存储所有用户的变量设置的文件是**/etc/profile**。 # 第二章 Linux系统的环境搭建 ### Linux操作系统与主机之间的网络构建 **网络模式**：桥接模式、NAT模式、仅主机模式（一般选择NAT模式） ### 配置ip地址 <img src \"image/1.jpg\" style \"zoom:67%;\" /> ``` #进入编辑/etc/sysconfig/network scripts/ifcfg ens33目录 vim /etc/sysconfig/network scripts/ifcfg ens33 #设置为静态地址 BOOTPROTO \"static\" #IP地址 IPADDR 192.168.101.100 #网关 GATEWAY 192.168.101.2 #域名解析器 DNS1 192.168.101.2 #重启 systemctl restart network ``` # 第三章 Linux操作基础 ### 简单命令 当前路径：pwd 日期命令：date 在线用户命令：who ``` #自己是谁 who am i ``` 日历命令：cal ``` cal #查看指定年份在cal后面加上年份（2022）不能缩写成（20） cal 2022 ``` 系统信息命令：uname <img src \"image/2.jpg\" style \"zoom:80%;\" /> su命令切换用户：su ``` #” “表示是否切换环境变量 su [ ] [用户名] ``` 清屏：clear 统计命令：wc ``` wc [ lw][ c] 文件名 # L:统计行数; W:统计字数; c:统计字节数; ``` ### Shell命令的操作基础 Shell：又称为linux命令，当用户登录后Shell运行进入内存，它遵循一定的语法将输入的命令加以解释并传给系统 ``` 命令名称 [选项][参数] ``` 帮助命令：man ``` man ls #空格：下一屏 #回车：滚动一行 #q：推出man命令 ``` ##### 目录和文件的操作 列出目录的内容：ls ``` #列出全部文件，包括以.开头的隐藏文件 ls a #列出文件的属性和权限等信息，等价于ll ls l ``` 切换目录：cd ``` cd [参数] ``` ![](image/3.jpg) 创建一个新的目录：mkdir ``` mkdir [选项] 要创建的目录 mkdir xiyou mkdir p xiyou/dssz/meihouwang ``` ![](image/4.jpg) 删除一个空的目录：rmdir ``` rmdir 要删除的空目录 ``` 创建空文件：touch ``` touch 要创建的文件 ``` 复制文件或目录：cp ``` cd [选项] 源文件 目标文件 #强制覆盖 /cd ``` ![](image/5.jpg) 移动文件与目录或重命名：移动文件或重命名 ``` mv 旧名字 新名字 mv 原路径 新路径 ``` 删除文件或目录：rm ``` rm [选项] 要删除的文件 ``` ![](image/6.jpg) 软链接：ln ``` ln s [文件或目录][软连接名] #删除软链接： rm rf 软链接名，而不是 rm rf 软链接名/ #如果使用 rm rf 软链接名/ 删除，会把软链接对应的真实目录下内容删掉 ``` ##### 查看输出文件操作 查看文件内容：cat ``` cat [选项] 要查看的文件 ``` 文件内容分屏查看器：more ``` more 要查看的文件 #一次显示一页 ``` ![](image/8.jpg) 分屏显示文件内容：less ``` less 要查看的文件 ``` ![](image/9.jpg) 显示文件头部内容：head ``` head [选项] 文件 ``` ![](image/10.jpg) 输出文件尾部内容：tail ``` tail [选项] 文件 ``` ![](image/11.jpg) 输出重定向和 追加：> >> ``` ls l > 文件 #将列表内容写入文件.txt中（覆盖） ls al >> 文件 #将列表内容追加到文件.txt的末尾 cat 文件1 > 文件2 ``` echo ``` echo [选项][输出内容] # e 支出反斜线字符转换 [atguigu@hadoop101 ~]$ echo “hello\\tworld” hello\\tworld [atguigu@hadoop101 ~]$ echo e “hello\\tworld” hello world ``` # 第四章 Linux系统与文件管理 ##### 用户管理命令 添加新用户：useradd / adduser ``` useradd 用户名 #添加新用户 useradd g 组名 用户名 #添加新用户到某个组 ``` 设置用户密码：passwd ``` passwd 用户名 #设置用户密码 ``` 查看用户是否存在：id ``` id 用户 #查看用户是否存在 ``` 查看创建了哪些用户：cat /etc/passwd ``` cat /etc/passwd cd /home ls ``` 切换用户：su ``` su 用户名 #切换用户，只能获取用户的权限，不能获得环境变量 su 用户名 #切换用户，并获得该用户的环境变量及执行权限 ``` 删除用户：userdel ``` userdel 用户名 #删除用户，但保留用户主目录 userdel r 用户名 #用户和用户主目录都删除 su tangseng ``` 设置普通用户具有 root 权限：sudo 需修改/etc/sudoers文件 ![](image/12.jpg) ``` sudo mksir /opt/module #在/opt目录下创建目录 ``` 修改用户：usermod ``` usermod g 用户组 用户名 #将用户加入用户组 ``` ##### 组管理命令 新增组：groupadd ``` groupadd 组名 ``` 删除组：groupdel ``` groupdel 组名 ``` 修改组：groupmod ``` groupmod n 新组名 旧组名 #改名 ``` 管理组内用户：gpasswd ``` gpasswd a 用户名 组名 #将用户添加到组中 gpasswd d 用户名 组名 #将用户从组中删除 gpasswd A 用户名 组名 #将用户设为组的管理员 ``` 查看创建了哪些组： cat /etc/group ``` cat /etc/group ``` ##### 文件权限管理 **文件的属性**：Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。 为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做 了不同的规定。在Linux中我们可以使用ll或者ls l命令来显示一个文件的属性以及文件所属 的用户和组。 ![](image/13.jpg) 如果没有权限，就会出现减号[ ]而已。从左至右用0 9这些数字来表示: （1）0 首位表示类型 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等 代表文件 d 代表目录 l 链接文档(link file)； （2）第1 3位确定属主（该文件的所有者）拥有该文件的权限。 User （3）第4 6位确定属组（所有者的同组用户）拥有该文件的权限， Group （4）第7 9位确定其他用户拥有该文件的权限 Other 改变权限：chmod ``` chmod [{ugoa}{+ }{rwx}] 文件或目录 #u:所有者 g:所有组 o:其他人 a:所有人(u、g、o的总和) chmod u x,o+x houge.txt chmod [mode 421] 文件或目录 #r 4 w 2 x 1 rwx 4+2+1 7 chmod 777 houge.txt ``` 改变所有者：chown ``` chown [选项] [最终用户][文件或目录] #改变文件或者目录的所有者 chown atguigu houge.txt ``` ![](image/14.jpg) 改变所属组：chgrp ``` chgrp [最终组] [文件或目录] #改变文件或者目录的所属组 chgrp root houge.txt ``` ##### 搜索查找命令 查找文件或者目录：find ``` find [搜索范围][选项] find /opt/ name \"*.jar\" find /opt/ user nginx ``` ![](image/15.jpg) 快速定位文件路径：locate 由于 locate 指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb 指令创 建 locate 数据库。 ``` locate 文件名字 ``` 过滤查找及“”管道符：grep 管道符，“”，表示将前一个命令的处理结果输出传递给后面的命令处理 ``` grep [选项] [查找内容] [源文件] ``` ![](image/16.jpg) ##### 压缩和解压命令 .gz压缩：gzip/gunzip （1）只能压缩文件不能压缩目录 （2）不保留原来的文件 （3）同时多个文件会产生多个压缩包 ``` gzip 文件 #压缩文件，只能将文件压缩为*.gz 文件 gzip houge.txt gunzip 文件 #解压缩文件命令 gunzip houge.txt.gz ``` 压缩：zip/unzip zip 压缩命令在windows/linux都通用，可以压缩目录且保留源文件。 ``` zip [选项] XXX.zip 将要压缩的内容 #压缩文件和目录的命令 root@hadoop101 opt]# touch bailongma.txt [root@hadoop101 ~]# zip mypackage.zip houge.txt bailongma.txt adding: houge.txt (stored 0%) adding: bailongma.txt (stored 0%) [root@hadoop101 opt]# ls houge.txt bailongma.txt mypackage.zip unzip [选项] XXX.zip #解压缩文件 [root@hadoop101 ~]# unzip mypackage.zip Archive: houma.zip extracting: houge.txt extracting: bailongma.txt [root@hadoop101 ~]# ls houge.txt bailongma.txt mypackage.zip ``` ![](image/17.jpg) 打包：tar ``` tar [选项] XXX.tar.gz 将要打包进去的内容 #打包目录，压缩后的文件格式.tar.gz tar zcvf lichao.tar.gz bailongma.txt houma.txt C/opt/app #压缩 tar zxvf lichao.tar.gz C /opt #解压 ``` ![](image/18.jpg) ##### RPM软件包 RPM（RedHat Package Manager），RedHat软件包管理工具，类似windows里面的setup.exe 是Linux这系列操作系统里面的打包安装工具，它虽然是RedHat的标志，但理念是通用的。 RPM包的名称格式：Apache 1.3.23 11.i386.rpm “apache” 软件名称 “1.3.23 11”软件的版本号，主版本和此版本 “i386”是软件所运行的硬件平台，Intel 32位处理器的统称 “rpm”文件扩展名，代表RPM包 RPM包安装：rpm ivh ``` rpm ivh 包名 #安装RPM rpm ivh firefox 45.0.1 1.el6.centos.x86_64.rpm ``` ![](image1/10.jpg) RPM包卸载：rpm e ``` rpm e 包名 #卸载RPM rpm e firefox rpm e nodeps 包名 ``` RPM包查询：rpm qa ``` rpm qa grep rpm rpm q 包名 #查询是否安装 ``` ##### YUM软件包 YUM（全称为 Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 CentOS 中的 Shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包 并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次 次下载、安装。 YUM 的常用命令：yum ``` yum [选项][参数] #采用 yum 方式安装 firefox yum y install firefox ``` ![](image1/11.jpg) ![](image1/12.jpg) ##### 磁盘查看和分类 查看文件和目录占用的磁盘空间：du ``` du 目录/文件 #显示目录下每个子目录的磁盘使用情况 du sh #查看当前用户主目录占用的磁盘空间大小 ``` ![](image/19.jpg) 查看磁盘空间使用情况：df ``` df [选项] #列出文件系统的整体磁盘使用量，检查文件系统的磁盘空间占用情况 df h #查看磁盘使用情况 ``` ![](image1/1.jpg) 查看设备挂载情况：lsblk ``` lsblk #查看设备挂载情况 ``` ![](image1/2.jpg) 挂载/卸载：mount/umount ``` mount [ t vfstype] [ o options] device dir #挂载设备 mount t iso9660 /dev/cdrom /mnt/cdrom/ #设备/dev/cdrom挂载到 挂载点：/mnt/cdrom 中 umount 设备文件名或挂载点 #卸载设备 umount /mnt/cdrom ``` <img src \"image1/3.jpg\" style \"zoom:70%;\" /> 设置开机自动挂载：vi /etc/fstab <img src \"image1/4.jpg\" style \"zoom:70%;\" /> 分区：fdisk ``` fdisk l #查看磁盘分区详情, l:显示所有硬盘的分区列表 fdisk 硬盘设备名 #对新增硬盘进行分区操作 ``` ##### 进程管理命令 进程：是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。/指进程实体的运行过程，是系统进行资源分配和调度的独立单位。或者说是一个程序在处理机上的一次执行活动 进程属性：系统启动后第一个运行的进程是systemd，它的进程号是1，systemd是惟一一个由系统内核直接运行的进程。 查看当前系统进程状态：ps 如果想查看进程的 CPU 占用率和内存占用率，可以使用 aux; 如果想查看进程的父进程 ID 可以使用 ef; ``` ps aux grep xxx #查看系统中所有进程 ps ef grep xxx #可以查看子父进程之间的关系 ``` ![](image1/5.jpg) 功能说明 ： （1）ps aux ​ 显示信息说明 ​ USER：该进程是由哪个用户产生的 ​ PID：进程的 ID 号 ​ %CPU：该进程占用 CPU 资源的百分比，占用越高，进程越耗费资源； ​ %MEM：该进程占用物理内存的百分比，占用越高，进程越耗费资源； ​ VSZ：该进程占用虚拟内存的大小，单位 KB； ​ RSS：该进程占用实际物理内存的大小，单位 KB； ​ TTY：该进程是在哪个终端中运行的。对于 CentOS 来说，tty1 是图形化终端， ​ tty2 tty6 是本地的字符界面终端。pts/0 255 代表虚拟终端。 ​ STAT：进程状态。常见的状态有：R：运行状态、S：睡眠状态、T：暂停状态、 Z：僵尸状态、s：包含子进程、l：多线程、+：前台显示 ​ START：该进程的启动时间 ​ TIME：该进程占用 CPU 的运算时间，注意不是系统时间 ​ COMMAND：产生此进程的命令名 （2）ps ef ​ 显示信息说明 ​ UID：用户 ID ​ PID：进程 ID ​ PPID：父进程 ID ​ C：CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算， 执行优先级会降低；数值越小，表明进程是 I/O 密集型运算，执行优先级会提高 ​ STIME：进程启动的时间 ​ TTY：完整的终端名称 ​ TIME：CPU 时间 ​ CMD：启动进程所用的命令和参数 终止进程：kill ``` kill [选项] 进程号 #通过进程号杀死进程 选项 9：强制杀死 killall 进程名称 #通过进程名称杀死进程，也支持通配符，这在系统因负载过os大而变得很慢时很有用 ``` 查看进程树：pstree ``` pstree [选项] ``` ![](image1/6.jpg) 实时监控系统进程状态：top ``` top [选项] ``` ![](image1/7.jpg) ![](image1/8.jpg) ![](image1/9.jpg) 显示网络状态和端口占用信息：netstat ``` netstat anp grep 进程号 #查看该进程网络信息 netstat –nlp grep 端口号 #查看网络端口号占用情况 ``` ##### 定时服务管理 service crond start //启动服务 service crond stop //关闭服务 service crond restart //重启服务 service crond reload //重新载入配置 ``` crontab [选项] crontab e #进入 crontab 编辑界面。会打开 vim 编辑你的 ``` ![](image2/13.jpg) ``` * * * * * 执行的任务 ``` ![](image2/14.jpg) ![](image2/15.jpg) # 第五章 VI/VIM编辑器 ### VI/VIM编辑器 VI 是 Unix 操作系统和类 Unix 操作系统中最通用的文本编辑器。 VIM 编辑器是从 VI 发展出来的一个性能更强大的文本编辑器。可以主动的以字体颜 色辨别语法的正确性，方便程序设计。VIM 与 VI 编辑器完全兼容。 ### vi编辑器启动与退出 ``` vi + n 文件名 #打开文件，光标在第n行 vi + 文件名 #打开文件，光标停在最末行行首: vi r 文件名 #恢复文件 vi + /词 文件名 #找到“词”的第一次出现的文件，光标在该行行首 :w #保存 :q #退出 :wq #保存并退出 :q! #强制退出 ``` ### vi编辑器的三种工作方式 ##### 一般模式、编辑模式、命令模式 ![](image1/18.jpg) ##### 命令模式、插入模式、底行命令模式 ![](image1/19.jpg) ##### 命令模式、输入模式 基于一般模式、编辑模式、命令模式 ##### 一般模式 以 vi 打开一个档案就直接进入一般模式了（这是默认的模式）。在这个模式中， 你可 以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档 案内容， 也可以使用『复制、粘贴』来处理你的文件数据。 ![](image1/20.jpg) ##### 编辑模式 在一般模式中可以进行删除、复制、粘贴等的动作，但是却无法编辑文件内容的！要 等到你按下『i, I, o, O, a, A』等任何一个字母之后才会进入编辑模式。 注意了！通常在Linux中，按下这些按键时，在画面的左下方会出现『INSERT或 REPLACE』的字样，此时才可以进行编辑。而如果要回到一般模式时， 则必须要按下 『Esc』这个按键即可退出编辑模式。 ![](image2/1.jpg) ##### 指令模式 在一般模式当中，输入『 : / ?』3个中的任何一个按钮，就可以将光标移动到最底下那 一行。 在这个模式当中， 可以提供你『搜寻资料』的动作，而读取、存盘、大量取代字符、 离开 vi 、显示行号等动作是在此模式中达成的！ ![](image2/2.jpg) # 第六章 Shell编程 ### Shell 概述 ![](image2/3.jpg) ##### Linux 提供的 Shell 解析器有 ``` [root@lichao donc]# cat /etc/shells /bin/sh /bin/bash /usr/bin/sh /usr/bin/bash /bin/tcsh /bin/csh /sbin/nologin ``` ##### bash 和 sh 的关系 ``` [atguigu@hadoop101 bin]$ ll grep bash rwxr xr x. 1 root root 941880 5 月 11 2016 bash lrwxrwxrwx. 1 root root 4 5 月 27 ``` ##### Centos 默认的解析器是 bash ``` [atguigu@hadoop101 bin]$ echo $SHELL /bin/bash ``` ### Shell 脚本入门 ##### 脚本格式 脚本以#!/bin/bash 开头（指定解析器） ##### 第一个 Shell 脚本 ``` [atguigu@hadoop101 shells]$ touch helloworld.sh [atguigu@hadoop101 shells]$ vim helloworld.sh 在 helloworld.sh 中输入如下内容 #!/bin/bash echo \"helloworld\" ``` 脚本的常用执行方式 第一种：采用 bash 或 sh+脚本的相对路径或绝对路径（不用赋予脚本+x 权限） ``` #sh+脚本的相对路径 [root@lichao scripts]# sh ./hello.sh hello world #sh+脚本的绝对路径 [root@lichao scripts]# sh /opt/donc/scripts/hello.sh hello world #bash+脚本的相对路径 [root@lichao scripts]# bash ./hello.sh hello world #bash+脚本的绝对路径 [root@lichao scripts]# bash /opt/donc/scripts/hello.sh hello world ``` 第二种：采用输入脚本的绝对路径或相对路径执行脚本（必须具有可执行权限+x） ``` #首先要赋予 helloworld.sh 脚本的+x 权限 chmod u+x hello.sh #相对路径 [root@lichao scripts]# ./hello.sh hello world #绝对路径 [root@lichao scripts]# /opt/donc/scripts/hello.sh hello world ``` （了解）第三种： 在脚本的路径前加上“.”或者 source 前两种方式都是在当前 shell 中打开一个子 shell 来执行脚本内容，当脚本内容结束，则 子 shell 关闭，回到父 shell 中。 第三种，也就是使用在脚本路径前加“.”或者 source 的方式，可以使脚本内容在当前 shell 里执行，而无需打开子 shell！这也是为什么我们每次要修改完/etc/profile 文件以后，需 要 source 一下的原因。 开子 shell 与不开子 shell 的区别就在于，环境变量的继承关系，如在子 shell 中设置的 当前变量，父 shell 是不可见的。 ##### 变量 系统预定义变量：$HOME、$PWD、$SHELL、$USER 等 ``` [root@lichao scripts]# echo $HOME /root [root@lichao scripts]# echo $PWD /opt/donc/scripts [root@lichao scripts]# echo $SHELL /bin/bash [root@lichao scripts]# echo $USER root #set 显示当前Shell中所有变量 set ``` 自定义变量 ``` 变量名 变量值 #定义变量， 号前不能有空格 unset 变量名 #撤销变量 readonly 变量名 #声明静态变量不能unset export 变量名 #把变量提升为全局环境变量，可供其他 Shell 程序使用 ``` 变量定义规则 变量名称可以由字母、数字和下划线组成，但是不能以数字开头，环境变量名建 议大写。 等号两侧不能有空格 在 bash 中，变量默认类型都是字符串类型，无法直接进行数值运算。 变量的值如果有空格，需要使用双引号或单引号括起来。 特殊变量 $n ``` $n #n 为数字，$0 代表该脚本名称，$1 $9 代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10} [atguigu@hadoop101 shells]$ touch parameter.sh [atguigu@hadoop101 shells]$ vim parameter.sh #!/bin/bash echo ' $n ' echo $0 echo $1 echo $2 [atguigu@hadoop101 shells]$ chmod 777 parameter.sh [atguigu@hadoop101 shells]$ ./parameter.sh cls xz $n ./parameter.sh cls xz ``` $# ``` $# #获取所有输入参数个数，常用于循环,判断参数的个数是否正确以及加强脚本的健壮性 [atguigu@hadoop101 shells]$ vim parameter.sh #!/bin/bash echo ' $n ' echo $0 echo $1 echo $2 echo ' $# ' echo $# [atguigu@hadoop101 shells]$ chmod 777 parameter.sh [atguigu@hadoop101 shells]$ ./parameter.sh cls xz $n ./parameter.sh cls xz $# 2 ``` $*、$@ ``` $* #这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体 $@ #这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待，可以使用for遍历 ）案例实操 [atguigu@hadoop101 shells]$ vim parameter.sh #!/bin/bash echo ' $n ' echo $0 echo $1 echo $2 echo ' $# ' echo $# echo ' $* ' echo $* echo ' $@ ' echo $@ [atguigu@hadoop101 shells]$ ./parameter.sh a b c d e f g $n ./parameter.sh a b $# 7 $* a b c d e f g $@ a b c d e f g ``` $? ``` $? 最后一次执行的命令的返回状态。如果这个变量的值为 0，证明上一个命令正确执行；如果这个变量的值为非 0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。 [atguigu@hadoop101 shells]$ ./helloworld.sh hello world [atguigu@hadoop101 shells]$ echo $? 0 ``` ##### 运算符 expr 1 + 2 expr 1 \\\\* 2 ``` $((运算式)) echo $((5*10)) $[运算式] echo $[(2+3)*4] #加法脚本 touch add.sh vim add.sh #!bin/bash sum $[$1+$2] echo sum $sum [root@lichao scripts]# sh add.sh 1 2 sum 3 ``` ##### 条件判断 test ``` test condition #（注意 condition 内部前后要有空格） [root@lichao scripts]# a 1 [root@lichao scripts]# test $a 2 [root@lichao scripts]# echo $? 1 [ condition ] #（注意 condition 前后要有空格） [root@lichao scripts]# [ $a 1 ] [root@lichao scripts]# echo $? 0 ``` 常用判断条件 两个整数之间比较 ![](image2/4.jpg) ``` [root@lichao scripts]# [ 23 eq 22 ] [root@lichao scripts]# echo $? 1 ``` 按照文件权限进行判断 ![](image2/5.jpg) ``` [root@lichao scripts]# [ x add.sh ] [root@lichao scripts]# echo $? 1 ``` 按照文件类型进行判断 ![](image2/6.jpg) ``` [root@lichao scripts]# [ f add.sh ] [root@lichao scripts]# echo $? 0 ``` 多条件判断 && 表示前一条命令执行成功时，才执行后一条命令， 表示上一 条命令执行失败后，才执行下一条命令 ``` [atguigu@hadoop101 ~]$ [ atguigu ] && echo OK echo notOK OK [atguigu@hadoop101 shells]$ [ ] && echo OK echo notOK notOK ``` ##### 流程控制 if 判断 ``` #单分支 if [ 条件判断式 ];then 程序 fi #或者 if [ 条件判断式 ] then 程序 fi #多分支 if [ 条件判断式 ] then 程序 elif [ 条件判断式 ] then 程序 else 程序 fi #实例 #!/bin/bash if [ $1 eq 1 ] then echo \"is 1\" elif [ $1 eq 2 ] then echo \"is 2\" else echo \"???\" fi [root@lichao scripts]# sh panduan.sh 1 is 1 [root@lichao scripts]# sh panduan.sh 2 is 2 [root@lichao scripts]# sh panduan.sh 3 ??? ``` case语句 ``` case $变量名 in \"值 1\"） 如果变量的值等于值 1，则执行程序 1 ;; \"值 2\"） 如果变量的值等于值 2，则执行程序 2 ;; …省略其他分支… *） 如果变量的值都不是以上的值，则执行此程序 ;; esac #实例 #!/bin/bash case $1 in \"1\") echo \"case is 1 \" ;; \"2\") echo \"case is 2 \" ;; \"3\") echo \"case is 3\" ;; *) echo \"qita\" ;; esac [root@lichao scripts]# sh caseTest.sh 1 case is 1 [root@lichao scripts]# sh caseTest.sh 5 qita ``` for 循环 ``` for (( 初始值;循环控制条件;变量变化 )) do 程序 done #实例 #!/bin/bash for ((a 0;a< 5;a++)) do echo $a done [root@lichao scripts]# sh forTest.sh 0 1 2 3 4 5 ``` ``` for 变量 in 值 1 值 2 值 3… do 程序 done #实例 #!/bin/bash for i in cls wly mls do echo this is $i done [root@lichao scripts]# sh forTest1.sh this is cls this is wly this is mls ``` 在for循环中$*和$@的区别 ``` #!/bin/bash echo ' $* ' for i in $* do echo \"ban zhang love $i\" done echo ' $@ ' for j in $@ do echo \"ban zhang love $j\" done #实例 [root@lichao scripts]# sh forTest2.sh 123 321 abc ddd $* ban zhang love 123 ban zhang love 321 ban zhang love abc ban zhang love ddd $@ ban zhang love 123 ban zhang love 321 ban zhang love abc ban zhang love ddd #!/bin/bash echo ' $* ' for i in \"$*\" #$*中的所有参数看成是一个整体，所以这个 for 循环只会循环一次 do echo \"ban zhang love $i\" done echo ' $@ ' for j in \"$@\" #$@中的每个参数都看成是独立的，所以“$@”中有几个参数，就会循环几次 do echo \"ban zhang love $j\" done [atguigu@hadoop101 shells]$ chmod 777 for4.sh [atguigu@hadoop101 shells]$ ./for4.sh cls mly wls $* banzhang love cls mly wls $@ banzhang love cls banzhang love mly ``` while 循环 ``` while [ 条件判断式 ] do 程序 done #实例 #!/bin/bash sum 0 i 1 while [ $i le 100 ] do sum $[$sum+$i] i $[$i+1] done echo $sum [root@lichao scripts]# sh whileTest.sh 5050 ``` ##### read 读取控制台输入 ``` read [选项] [参数] #选项 # p：指定读取值时的提示符； # t：指定读取值时等待的时间（秒）如果 t 不加表示一直等待 #参数 #变量：指定读取值的变量名 不用提前定义 #实例 #!/bin/bash sum 0 i 0 read p \"Enter you rea: \" rea while [ $i le $rea ] do sum $[$sum+$i] i $[$i+1] done echo $sum [root@lichao scripts]# sh readTest.sh Enter you rea: 100 5050 ``` ##### break和continue 和其他语言一样 break：用于提前结束循环 continue：用于结束本次循环，进入下一次循环 ##### 函数 系统函数 basename ``` #basename 命令会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符串显示出来 #basename 可以理解为取路径里的文件名 basename [string / pathname] [suffix] #实例 [root@lichao scripts]# basename /opt/donc/scripts/whileTest.sh whileTest.sh [root@lichao scripts]# basename /opt/donc/scripts/whileTest.sh .sh whileTest ``` dirname ``` #从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分） #dirname 可以理解为取文件路径的绝对路径名称 dirname 文件绝对路径 #实例 [root@lichao scripts]# dirname /opt/donc/scripts/whileTest.sh /opt/donc/scripts ``` 自定义函数 ``` [ function ] funname[()] { Action; [return int;] } #实例 #!/bin/bash function sum() { echo $[$1+$2] } read p \"place scanf numb1:\" numb1 read p \"place scanf numb2:\" numb2 sum $numb1 $numb2 ``` ##### 正则表达式入门 正则表达式使用单个字符串来描述、匹配一系列符合某个语法规则的字符串。在很多文 本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。在 Linux 中，grep， sed，awk 等文本处理工具都支持通过正则表达式进行模式匹配。 常规匹配 ``` #一串不包含特殊字符的正则表达式匹配它自己 [root@lichao scripts]# cat /etc/passwd grep lichao lichao:x:1000:1000:lichao:/home/lichao:/bin/bash ``` 常用特殊字符 特殊字符：^ ``` #^ 匹配一行的开头 [root@lichao scripts]# cat /etc/passwd grep ^l lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin libstoragemgmt:x:998:995:daemon account for libstoragemgmt:/var/run/lsm:/sbin/nologin lichao:x:1000:1000:lichao:/home/lichao:/bin/bash #会匹配出所有以 a 开头的行 ``` 特殊字符：$ ``` #$ 匹配一行的结束 cat /etc/passwd grep t$ #会匹配出所有以 t 结尾的行 halt:x:7:0:halt:/sbin:/sbin/halt ``` 一起使用：^$ ``` [root@lichao scripts]# ls grep ^hello.sh$ hello.sh ``` 特殊字符：* ``` #* 不单独使用，他和上一个字符连用，表示匹配上一个字符 0 次或多次，和SQL语言中的*类似 [root@lichao scripts]# cat /etc/passwd grep ro*t root:x:0:0:root:/root:/bin/bash ``` 特殊字符：. ``` #匹配一个任意的字符，和SQL语言中的.似 [root@lichao scripts]# cat /etc/passwd grep r..t root:x:0:0:root:/root:/bin/bash ``` 字符区间（中括号）：[ ] ``` [ ] 表示匹配某个范围内的一个字符，例如 [6,8] 匹配 6 或者 8 [0 9] 匹配一个 0 9 的数字 [0 9]* 匹配任意长度的数字字符串 [a z] 匹配一个 a z 之间的字符 [a z]* 匹配任意长度的字母字符串 [a c, e f] 匹配 a c 或者 e f 之间的任意字符 cat /etc/passwd grep r[a,b,c]*t ``` 特殊字符：\\ ``` \\ 表示转义，并不会单独使用。由于所有特殊字符都有其特定匹配模式，当我们想匹配 某一特殊字符本身时（例如，我想找出所有包含 '$' 的行），就会碰到困难。此时我们就要 将转义字符和特殊字符连用，来表示特殊字符本身 cat /etc/passwd grep ‘a\\$b’ #就会匹配所有包含 a$b 的行。注意需要使用单引号将表达式引起来。 ``` ##### 文本处理工具 cut ``` cut [选项参数] filename ``` 选项参数 功能 : :: : f 列号，提取第几列 d 分隔符，按照指定分隔符分割列，默认是制表符\"\\t\" c 按字符进行切割，后加n表示取第几列，比如 c 1 awk 一个强大的文本分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理 ``` awk [选项参数] ‘/pattern1/{action1} /pattern2/{action2}...’ filename pattern：表示 awk 在数据中查找的内容，就是匹配模式 action：在找到匹配内容时所执行的一系列命令 ``` ##### 归档文件 ``` #!/bin/bash # 首先判断输入参数个数是否为 1 if [ $# ne 1 ] then echo \"参数个数错误！应该输入一个参数，作为归档目录名\" exit fi # 从参数中获取目录名称 if [ d $1 ] then echo else echo echo \"目录不存在！\" echo exit fi DIR_NAME $(basename $1) DIR_PATH $(cd $(dirname $1); pwd) # 获取当前日期 DATE $(date +%y%m%d) # 定义生成的归档文件名称 FILE archive_${DIR_NAME}_$DATE.tar.gz DEST /root/archive/$FILE # 开始归档目录文件 echo \"开始归档...\" echo tar czf $DEST $DIR_PATH/$DIR_NAME if [ $? eq 0 ] then echo echo \"归档成功！\" echo \"归档文件为：$DEST\" echo else echo \"归档出现问题！\" echo fi exit ``` ##### 发送消息 我们可以利用 Linux 自带的 mesg 和 write 工具，向其它用户发送消息。 需求：实现一个向某个用户快速发送消息的脚本，输入用户名作为第一个参数，后面直 接跟要发送的消息。脚本需要检测用户是否登录在系统中、是否打开消息功能，以及当前发 送消息是否为空。 ``` #!/bin/bash login_user $(who grep i m 1 $1 awk '{print $1}') if [ z $login_user ] then echo \"$1 不在线！\" echo \"脚本退出..\" exit fi is_allowed $(who T grep i m 1 $1 awk '{print $2}') if [ $is_allowed ! \"+\" ] then echo \"$1 没有开启消息功能\" echo \"脚本退出..\" exit fi if [ z $2 ] then echo \"没有消息发出\" echo \"脚本退出..\" exit fi whole_msg $(echo $* cut d \" \" f 2 ) user_terminal $(who grep i m 1 $1 awk '{print $2}') echo $whole_msg write $login_user $user_terminal if [ $? ! 0 ] then echo \"发送失败！\" else echo \"发送成功！\" fi exit ```"},"/Linux/在Ubuntu上安装PostgreSQL 13.html":{"title":"在Ubuntu上安装PostgreSQL 13","content":"# 在Ubuntu上安装PostgreSQL 13 ## 方法一：使用官方APT仓库 ### 1. 添加PostgreSQL官方仓库 ```shell # 更新系统包列表 sudo apt update # 安装必要的依赖 sudo apt install wget curl gnupg2 software properties common apt transport https ca certificates lsb release ubuntu keyring # 导入PostgreSQL签名密钥 curl fsSL https://www.postgresql.org/media/keys/ACCC4CF8.asc sudo gpg dearmor o /usr/share/keyrings/postgresql key.gpg # 添加PostgreSQL仓库 echo \"deb [signed by /usr/share/keyrings/postgresql key.gpg] http://apt.postgresql.org/pub/repos/apt $(lsb_release cs) pgdg main\" sudo tee /etc/apt/sources.list.d/pgdg.list ``` ### 2. 安装PostgreSQL 13 ```shell # 更新包列表 sudo apt update # 安装PostgreSQL 13 sudo apt install postgresql 13 postgresql client 13 ``` ## 方法二：使用Ubuntu默认仓库 ```shell # 更新包列表 sudo apt update # 安装PostgreSQL（这会安装Ubuntu仓库中的最新版本） sudo apt install postgresql postgresql contrib ``` ## 安装后的配置 ### 1. 检查PostgreSQL服务状态 ```shell sudo systemctl status postgresql@13 main # 或者 sudo systemctl status postgresql ``` ### 2. 启动和启用服务 ```shell # 启动服务 sudo systemctl start postgresql@13 main # 设置开机自启 sudo systemctl enable postgresql@13 main # 重启服务 sudo systemctl restart postgresql@13 main ``` ### 3. 连接到PostgreSQL ```shell # 切换到postgres用户 sudo u postgres psql # 或者直接连接 sudo u postgres psql d postgres ``` ### 4. 基本配置 ```shell # 修改postgres用户密码 sudo u postgres psql c \"ALTER USER postgres PASSWORD 'your_password';\" # 创建新数据库 sudo u postgres createdb mydatabase # 创建新用户 sudo u postgres createuser interactive ``` ## 配置文件位置 主配置文件：`/etc/postgresql/13/main/postgresql.conf` 访问控制文件：`/etc/postgresql/13/main/pg_hba.conf` 数据目录：`/var/lib/postgresql/13/main/` ## 常用管理命令 ```shell # 启动服务 sudo systemctl start postgresql@13 main # 停止服务 sudo systemctl stop postgresql@13 main # 重启服务 sudo systemctl restart postgresql@13 main # 查看服务状态 sudo systemctl status postgresql@13 main # 查看日志 sudo tail f /var/log/postgresql/postgresql 13 main.log ``` ## 验证安装 ```shell # 检查版本 psql version # 连接到数据库测试 sudo u postgres psql c \"SELECT version();\" ``` 安装完成后，你就可以开始使用PostgreSQL 13了。记得根据你的需求适当调整配置文件。"},"/Linux/lvs.html":{"title":"1 构建高可用集群","content":"# 1 构建高可用集群 ## 1.1 什么是高可用集群 高可用集群（High Availability Cluster，简称HA Cluster），是指以减少服务中断时间为目的得服务器 集群技术。它通过保护用户得业务程序对外部间断提供的服务，把因为软件，硬件，认为造成的故障对 业务得影响降低到最小程度。总而言之就是保证公司业务7*24小时不宕机 ### 1.2 高可用衡量标准 衡量集群的可用性(HA)高低，可以从MTTF（平均无故障时间）和MTTR（平均故障维修时间）进行考 量，公式为：HA MTTF/(MTTF+MTTR)*100%，具体衡量标准可以参考下表 ![](./p/1.png) ### 1.3 高可用保障 对集群中的服务器进行`负载均衡`、`健康监测`，并在服务器出现故障时能进行`故障转移`，自动切换到正常 服务器`是高可用保障的必要手段` ### 1.3.1 负载均衡 常见的负载均衡手段如下： 硬件负载均衡，如`F5` 软件负载均衡，如`nginx、haproxy、lvs` 几种软件负载均衡技术比较: ![](./p/2.png) ### 1.3.2 健康监测和自动切换 常见的健康监测和自动切换软件有keepAlived和heartBeat，其二者对比如下: Keepalived使用更简单：从安装、配置、使用、维护等角度上对比，Keepalived都比Heartbeat要简单 Heartbeat功能更强大：Heartbeat虽然复杂，但功能更强大，配套工具更全，适合做大型集群管理， 而Keepalived主要用于集群倒换，基本没有管理功能. ![](./p/3.png) ## 1.4 高可用拓扑图 # 2 软件负载均衡技术LVS ## 2.1 LVS简介 ### 2.1.1 什么是lvs 础知识:网络协议必知必会 LVS是Linux Virtual Server的简写，在1998年5月由章文嵩博士成立。 工作在OSI模型的四层，基于IP进行负载均衡。 在linux2.2内核时，IPVS就已经以内核补丁的形式出现。 从2.4版本以后，IPVS已经成为linux官方标准内核的一部分。 a. lvs项目介绍 http://www.linuxvirtualserver.org/zh/lvs1.html b. lvs集群的体系结构 http://www.linuxvirtualserver.org/zh/lvs2.html c. lvs集群中的IP负载均衡技术 http://www.linuxvirtualserver.org/zh/lvs3.html d. lvs集群的负载调度 http://www.linuxvirtualserver.org/zh/lvs4.html e. lvs中文站点 http://zh.linuxvirtualserver.org ### 2.1.2 lvs官方资料链接 ## 2.2 lvs拓扑 ### 2.2.1 lvs术语 LVS服务器(DS) 集群中节点服务器(RS) 虚拟IP地址（VIP），用于向客户端提供服务的IP地址（配置于负载均衡器上） 真实服务器的IP地址（RIP）， 集群中节点服务器的IP地址 负载均衡器IP地址（DIP），负载均衡器的IP地址，物理网卡上的IP 客户端主机IP地址（CIP），终端请求用户的主机IP地址 ### 2.2.2 工作原理和拓扑图 LVS负载均衡调度技术是在linux内核中实现的，使用配置LVS时，`不是直接配置内核中的IPVS`，而是通 过IPVS的管理工具`IPVSADM来管理配置`，LVS集群负载均衡器接受所有入站客户端的请求，并根据算法 来决定由哪个集群的节点来处理请求。 ![](./p/4.png) ## 2.3 lvs的四种工作模式 ### 2.3.1 TUN模式 TUN(Tunneling)模式需要服务器支持IP隧道（IP tunneling）技术，`限制较大，一般不用。` ![](./p/5.png) ### 2.3.2 NAT模式 AT(Network Address Translation)模式是基于NAT技术实现的。在此模式中，`LVS服务器既要处理请 求的接入，又要处理请求的响应。因此存在较大的性能瓶颈。` ![](./p/6.png) ### 2.3.3 DR模式 DR(Direct Routing)模式是`LVS的默认工作模式，也叫直接路由模式。`只处理请求的接入，不处理请求的 响应。`因此性能高，瓶颈小。` ![](./p/7.png) ### 2.3.4 FULLNAT模式 FULLNAT( Full Network Address Translation)可以说是淘宝定制化的技术，linux内核不支持。 ## 2.4 LVS调度算法 ## 2.4.1 静态调度算法 ![](./p/8.png) ### 2.4.2 动态调度算法 ![](./p/9.png) ## 2.5 lvs基本命令 对于lvs的操作，主要是通过ipvsadm软件实现，常用的lvs操作命令如下: ### 2.5.1 集群服务管理 ![](./p/10.png) ### 2.5.2 集群RS管理 ![](./p/11.png) ## 2.6 lvs实战 ### 2.6.1 NAT模式实战 ![](./p/12.png) ```bash vi /etc/sysctl.conf #添加如下内容并保存退出 net.ipv4.ip_forward 1 #执行如下命令使修改生效 sysctl p ``` ```bash #指定负载80端口的VIP，并指定调度策略为轮询 [root@lvs01 ~]# ipvsadm A t 10.0.0.8:80 s rr #添加两台RS，并指定负载均衡工作模式为NAT [root@lvs01 ~]# ipvsadm a t 10.0.0.8:80 r 192.168.25.112 m [root@lvs01 ~]# ipvsadm a t 10.0.0.8:80 r 192.168.25.113 m #查看上述配置是否生效 [root@lvs01 ~]# ipvsadm Ln IP Virtual Server version 1.2.1 (size 4096) Prot LocalAddress:Port Scheduler Flags > RemoteAddress:Port Forward Weight ActiveConn InActConn TCP 10.0.0.8:80 rr > 192.168.25.112:80 Masq 1 0 0 > 192.168.25.113:80 Masq 1 0 0 ``` NAT模式存在的问题–>LVS性能瓶颈 ### 2.6.2 DR模式实战 ARP（Address Resolution Protocol）地址解析协议，是根据IP地址获取物理地址 （MAC）的一个 TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的 所有主机，并接收返 回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址 存入本机ARP缓存中并 保留一定时间，下次请求时直接查询ARP缓存以节约资源。 DR模式拓扑图 ![](./p/13.png) ### 2.6.3 四个问题 a. 如果LVS服务器挂了会出现什么问题? b. 如何进行故障转移、自动切换? b. 如果后端某台RS服务器挂了会出现什么问题？ d. 如何获知RS服务器状态? # 3 KeepAlived ## 3.1 keepAlived简介 Keepalived的作用是检测服务器状态，如果有一台web服务器宕机，或工作出现故障，Keepalived将检 测到，并将有故障的服务器从系统中剔除，同时使用其他服务器代替该服务器的工作，当服务器工作正 常后Keepalived自动将服务器加入到服务器群中 ## 3.2 keepAlived主要特点 ### 3.2.1 健康检查 ![](./p/14.png) ### 3.2.2 故障迁移 VRRP协议 在现实的网络环境中。主机之间的通信都是通过配置静态路由或者(默认网关)来完成的，而主机之间的 路由器一旦发生故障，通信就会失效，因此这种通信模式当中，路由器就成了一个单点瓶颈，为了解决 这个问题，就引入了VRRP协议。 VRRP协议是一种容错的主备模式的协议，保证当主机的下一跳路由出现故障时，由另一台路由器来代 替出现故障的路由器进行工作，通过VRRP可以在网络发生故障时透明的进行设备切换而不影响主机之 间的数据通信。 故障迁移原理 在 Keepalived 服务正常工作时，主 Master 节点会不断地向备节点发送（多播的方式）心跳消息，用 以告诉备 Backup 节点自己还活着，当主 Master 节点发生故障时，就无法发送心跳消息，备节点也就 因此无法继续检测到来自主 Master 节点的心跳了，于是调用自身的接管程序，接管主 Master 节点的 IP 资源及服务。而当主 Master 节点恢复时，备 Backup 节点又会释放主节点故障时自身接管的 IP 资源 及服务，恢复到原来的备用角色。 ## 3.3 keepAlived原理 ## 3.4 分布式选主策略 ### 3.4.1 仅设置priority 在一个一主多备的Keepalived集群中，priority值最大的将成为集群中的MASTER节点，而其他都是 BACKUP节点。在MASTER节点发生故障后，BACKUP节点之间将进行“民主选举”，通过对节点优先级值 priority和weight的计算，选出新的MASTER节点接管集群服务。 ### 3.4.2 设置priority和weight weight值为正数时 在vrrp_script中指定的脚本如果检测成功，那么MASTER节点的权值将是weight值与priority值之和；如 果脚本检测失效，那么MASTER节点的权值保持为priority值 MASTER 节点vrrp_script脚本检测失败时，如果MASTER节点priority值小于BACKUP节点weight值与 priority值之和，将发生主、备切换。 MASTER节点vrrp_script脚本检测成功时，如果MASTER节点weight值与priority值之和大于BACKUP节 点weight值与priority值之和，主节点依然为主节点，不发生切换。 weight值为负数时 在vrrp_script中指定的脚本如果检测成功，那么MASTER节点的权值仍为priority值，当脚本检测失败 时，MASTER节点的权值将是priority值与weight值之差 MASTER节点vrrp_script脚本检测失败时，如果MASTER节点priority值与weight值之差小于BACKUP节 点priority值，将发生主、备切换。 MASTER节点vrrp_scrip脚本检测成功时，如果MASTER节点priority值大于BACKUP节点priority值时， 主节点依然为主节点，不发生切换。 weight设置标准 对于weight值的设置，有一个简单的标准，即weight值的绝对值要大于MASTER和BACKUP节点priority 值之差。由此可见，对于weight值的设置要非常谨慎，如果设置不好，主节点发生故障时将导致集群角 色选举失败，使集群陷于瘫痪状态。"},"/Linux/Nginx/index.html":{"title":"1.安装nginx","content":"# 1.安装nginx 在实验一的基础上，在/opt目录下创建src目录，并进入该目录，用于存放安装包 ```linux cd /opt mkdir src cd src ``` 在src目录下安装nginx安装包 ```linux wget https://nginx.org/download/nginx 1.22.1.tar.gz ``` 用ls指令查看nginx.gz压缩包，并用tar命令解压，解压完成后进入nginx文件 ```linux tar zxvf nginx 1.22.1.tar.gz cd nginx 1.22.1 ``` ls指令查看该文件内容 ![](image/1.jpg) 执行configure文件，之后再执行make install ``` ./configure prefix /opt/nginx make install ``` 在此过程中如果缺少相关文件报错，执行以下代码，再重复上一步操作 ``` yum install y zlib devel.x86_64 pcre2 devel.x86_64 #centOS apt install y zlib1g dev libpcre2 dev #ubantu ``` 进入/opt/nginx，查看该目录下内容 ![](image/2.jpg) 进入conf查看配置文件nginx.conf,默认80端口打开 ``` server { listen 80; server_name localhost; location / { root html; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location /50x.html { root html; } } ``` 输入以下代码，将防火墙打开 ``` firewall cmd zone public add port 80/tcp permanent systemctl restart firewalld.service ``` 在网页中输入ip地址，通过80端口访问，如：192.168.101.100:80 ![](image/3.jpg) 进入nginx目录下的html目录，编辑其中默认index界面 ``` cd /opt/nginx/html vim index.html ``` ![](image/14.jpg) 添加以下内容，并保存 ``` <p>我是软件202班李超同学</p> ``` ![](image/15.jpg) 再次在网页中输入ip地址，通过80端口访问，如：192.168.101.100:80，发现中文部分乱码 ![](image/17.jpg) 重新编辑index.html文件在<head></head>中加入网页的编码类型，如utf 8 ``` <meta charset \"UTF 8\"> ``` ![](image/18.jpg) 重新访问地址，发现内容正常输出 ![](image/16.jpg) # 2.配置jdk 在/opt/src中下载jdk包 ```linux wget https://download.java.net/java/GA/jdk19.0.1/afdd2e245b014143b62ccb916125e3ce/10/GPL/openjdk 19.0.1_linux x64_bin.tar.gz ``` 解压到/usr/local/目录下，并编辑/etc/profile，添加以下内容到末尾，结束后使用source点命令，重新执行刚修改的初始化文件，使之立即生效，再输入java version查看jdk版本来确定是否配置成功 ``` tar C /usr/local/ zxvf openjdk 19.0.1_linux x64_bin.tar.gz vim /etc/profile export JAVA_HOME /usr/local/jdk 19.0.1 export PATH $JAVA_HOME/bin:$PATH export CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar source /etc/profile java version ``` ![](image/23.jpg) # 3.创建springboot工程 使用idea创建一个Springboot项目 ![](image/4.jpg) 选择Spring Web ![](image/5.jpg) 创建controllerbao包，并创建TextControllerlei类，编写以下方法 ![](image/6.jpg) 用浏览器访问localhost:8080/hello ![](image/7.jpg) 打包 ![](image/8.jpg) 找到项目jar包 ![](image/9.jpg) 重复上述方法，再创建一个Springboot项目，将TextControllerlei类中hello方法返回值改成以下内容，并打包 ![](image/19.jpg) 在/opt目录下创建app目录，并将jar包通过Xftp放入其中 ``` cd /opt mkdir app cd app ``` ![](image/10.jpg) 输入以下代码将java项目在后台执行，并重定向输入到Log_demo8080.log文件中 ``` #负载均衡时通过8080和8081同时启动，运用权重来分配访问的频率 nohup java jar lichao 0.0.1 SNAPSHOT.jar > Log_demo8080.log 2>&1 & nohup java jar lichao1 0.0.1 SNAPSHOT.jar server.port 8081 > Log_demo8081.log 2>&1 & ps aux grep java curl http://localhost:8080/hello curl http://localhost:8081/hello ``` ![](image/11.jpg) ![](image/20.jpg) # 4.配置负载均衡 回到/opt/nginx/conf/目录下，vim编辑nginx.conf文件 ``` cd /opt/nginx/conf/ vim nginx.conf ``` 在nginx.conf中添加一个上游服务器，在这里配置负载均衡 ``` upstream lichao { server 127.0.0.1:8080 weight 1; server 127.0.0.1:8081 weight 1; } ``` 在nginx.conf中location将内容注释掉，并反向代理到负载均衡 ``` location / { #root html; #index index.html index.htm; proxy_pass http://lichao; } ``` 修改后重新加载一下配置文件 ``` ../sbin/nginx t ../sbin/nginx s reload #如果报错：nginx: [error] invalid PID number \"\" in \"/opt/nginx/logs/nginx.pid\" #执行以下指令 /opt/nginx/sbin/nginx c /opt/nginx/conf/nginx.conf ``` 再次访问ip地址 ![](image/12.jpg) 加入/hello后缀 ![](image/13.jpg) 尝试不断刷新网页，可以发现内容中application1和application2在不断切换，确定能正确交替返回上述两个tomcat的内容 ![](image/21.jpg) 通过curl命令访问[http://localhost/hello](http://localhost/hello)，确认能正确交替返回上述两个tomcat的内容。 ![](image/22.jpg)"}}